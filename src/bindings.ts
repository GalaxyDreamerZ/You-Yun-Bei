/* tslint:disable */
// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/


export const commands = {
async openUrl(url: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("open_url", { url }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async openFileOrFolder(path: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("open_file_or_folder", { path }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async chooseSaveFile() : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("choose_save_file") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async chooseSaveDir() : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("choose_save_dir") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getLocalConfig() : Promise<Result<Config, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_local_config") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async addGame(game: Game) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("add_game", { game }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async restoreSnapshot(game: Game, date: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("restore_snapshot", { game, date }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async deleteSnapshot(game: Game, date: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_snapshot", { game, date }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async deleteGame(game: Game) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_game", { game }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async getGameSnapshotsInfo(game: Game) : Promise<Result<GameSnapshots, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_game_snapshots_info", { game }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setConfig(config: Config) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_config", { config }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async resetSettings() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("reset_settings") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async createSnapshot(game: Game, describe: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("create_snapshot", { game, describe }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async openBackupFolder(game: Game) : Promise<Result<boolean, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("open_backup_folder", { game }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async checkCloudBackend(backend: Backend) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("check_cloud_backend", { backend }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async cloudUploadAll(backend: Backend) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("cloud_upload_all", { backend }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async cloudDownloadAll(backend: Backend) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("cloud_download_all", { backend }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setSnapshotDescription(game: Game, date: string, describe: string) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_snapshot_description", { game, date, describe }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async backupAll() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("backup_all") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async applyAll() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("apply_all") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async setQuickBackupGame(game: Game) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("set_quick_backup_game", { game }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Resolves a path string containing variables to an actual filesystem path
 * 
 * This command allows the frontend to resolve paths with variables like <home>, <winAppData>, etc.
 */
async resolvePath(path: string) : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("resolve_path", { path }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Returns the current device, if not found, returns a default device
 */
async getCurrentDeviceInfo() : Promise<Result<Device, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_current_device_info") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async toggleQuickActionSoundPreview(preferences: QuickActionSoundPreferences, effect: QuickActionSoundEffect) : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("toggle_quick_action_sound_preview", { preferences, effect }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async stopSoundPlayback() : Promise<Result<null, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("stop_sound_playback") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
async chooseQuickActionSoundFile() : Promise<Result<string, string>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("choose_quick_action_sound_file") };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
}
}

/** user-defined events **/


export const events = __makeEvents__<{
ipcNotification: IpcNotification,
quickActionCompleted: QuickActionCompleted
}>({
ipcNotification: "ipc-notification",
quickActionCompleted: "quick-action-completed"
})

/** user-defined constants **/

export const DEFAULT_CONFIG = {"backup_path":"./save_data","devices":{},"favorites":[],"games":[],"quick_action":{"enable_notification":true,"enable_sound":true,"hotkeys":{"apply":["","",""],"backup":["","",""]},"quick_action_game":null,"sounds":{"failure":{"kind":"default"},"success":{"kind":"default"}}},"settings":{"add_new_to_favorites":false,"cloud_settings":{"always_sync":false,"auto_sync_interval":0,"backend":{"type":"Disabled"},"root_path":"/game-save-manager"},"default_delete_before_apply":false,"default_expend_favorites_tree":false,"exit_to_tray":true,"extra_backup_when_apply":true,"home_page":"/","locale":"zh_SIMPLIFIED","log_to_file":true,"prompt_when_auto_backup":true,"prompt_when_not_described":false,"save_list_expand_behavior":"always_closed","save_list_last_expanded":false,"show_edit_button":false},"version":"1.5.4"} as const;

/** user-defined types **/

export type Backend = { type: "Disabled" } | 
/**
 * WebDAV 后端
 * 参考：https://docs.rs/opendal/latest/opendal/services/struct.Webdav.html
 * 不支持 blocking
 */
{ type: "WebDAV"; endpoint: string; username: string; password: string } | 
/**
 * Amazon S3 后端
 * 参考：https://docs.rs/opendal/latest/opendal/services/struct.S3.html
 * 不支持 rename 和 blocking
 */
{ type: "S3"; endpoint: string; bucket: string; region: string; access_key_id: string; secret_access_key: string }
export type CloudSettings = { 
/**
 * 是否启用跟随云同步（用户添加、删除时自动同步）
 */
always_sync?: boolean; 
/**
 * 同步间隔，单位分钟，为0则不自动同步
 */
auto_sync_interval?: number; 
/**
 * 云同步根目录
 */
root_path?: string; 
/**
 * 云同步后端设置
 */
backend?: Backend }
/**
 * The software's configuration
 * include the version, backup's location path, games'info,
 * and the settings
 */
export type Config = { version: string; backup_path: string; games: Game[]; settings: Settings; favorites?: FavoriteTreeNode[]; quick_action?: QuickActionsSettings; 
/**
 * 设备ID到设备名称的映射
 */
devices?: Partial<{ [key in string]: Device }> }
export type Device = { id: string; name: string }
export type FavoriteTreeNode = { node_id: string; label: string; is_leaf: boolean; children: FavoriteTreeNode[] | null }
/**
 * A game struct contains the save units and the game's launcher
 */
export type Game = { name: string; save_paths: SaveUnit[]; game_paths?: Partial<{ [key in string]: string }> }
/**
 * A backup list info is a json file in a backup folder for a game.
 * It contains the name of the game,
 * and all backups' path
 */
export type GameSnapshots = { name: string; backups: Snapshot[] }
export type IpcNotification = { level: NotificationLevel; title: string; msg: string }
export type NotificationLevel = "info" | "warning" | "error"
export type QuickActionCompleted = { operation: QuickActionOperation; status: QuickActionStatus; trigger: QuickActionType; game_name: string | null }
export type QuickActionHotkeys = { apply: string[]; backup: string[] }
export type QuickActionOperation = "Backup" | "Apply"
export type QuickActionSoundEffect = "Success" | "Failure"
export type QuickActionSoundPreferences = { enable_sound?: boolean; sounds?: QuickActionSoundSlots }
export type QuickActionSoundSlots = { success?: QuickActionSoundSource; failure?: QuickActionSoundSource }
export type QuickActionSoundSource = { kind: "default" } | { kind: "file"; path: string }
export type QuickActionStatus = "Success" | "Failure"
export type QuickActionType = "Timer" | "Tray" | "Hotkey"
export type QuickActionsSettings = { quick_action_game?: Game | null; hotkeys?: QuickActionHotkeys; enable_sound?: boolean; enable_notification?: boolean; sounds?: QuickActionSoundSlots }
/**
 * Settings that can be configured by user
 */
export type SaveListExpandBehavior = "always_open" | "always_closed" | "remember_last"
/**
 * A save unit declares one of the files/folders
 * that should be backup for a game
 */
export type SaveUnit = { unit_type: SaveUnitType; paths?: Partial<{ [key in string]: string }>; delete_before_apply?: boolean }
/**
 * A save unit should be a file or a folder
 */
export type SaveUnitType = "File" | "Folder"
export type Settings = { prompt_when_not_described?: boolean; extra_backup_when_apply?: boolean; show_edit_button?: boolean; prompt_when_auto_backup?: boolean; exit_to_tray?: boolean; cloud_settings?: CloudSettings; locale?: string; default_delete_before_apply?: boolean; default_expend_favorites_tree?: boolean; home_page?: string; log_to_file?: boolean; add_new_to_favorites?: boolean; save_list_expand_behavior?: SaveListExpandBehavior; save_list_last_expanded?: boolean }
/**
 * A backup is a zip file that contains
 * all the file that the save unit has declared.
 * The date is the unique indicator for a backup
 */
export type Snapshot = { date: string; describe: string; path: string; size?: number }

/** tauri-specta globals **/

import {
	invoke as TAURI_INVOKE,
	Channel as TAURI_CHANNEL,
} from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

type __EventObj__<T> = {
	listen: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
	once: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
	emit: null extends T
		? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
		: (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> =
	| { status: "ok"; data: T }
	| { status: "error"; error: E };

function __makeEvents__<T extends Record<string, any>>(
	mappings: Record<keyof T, string>,
) {
	return new Proxy(
		{} as unknown as {
			[K in keyof T]: __EventObj__<T[K]> & {
				(handle: __WebviewWindow__): __EventObj__<T[K]>;
			};
		},
		{
			get: (_, event) => {
				const name = mappings[event as keyof T];

				return new Proxy((() => {}) as any, {
					apply: (_, __, [window]: [__WebviewWindow__]) => ({
						listen: (arg: any) => window.listen(name, arg),
						once: (arg: any) => window.once(name, arg),
						emit: (arg: any) => window.emit(name, arg),
					}),
					get: (_, command: keyof __EventObj__<any>) => {
						switch (command) {
							case "listen":
								return (arg: any) => TAURI_API_EVENT.listen(name, arg);
							case "once":
								return (arg: any) => TAURI_API_EVENT.once(name, arg);
							case "emit":
								return (arg: any) => TAURI_API_EVENT.emit(name, arg);
						}
					},
				});
			},
		},
	);
}
